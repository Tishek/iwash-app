"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactNative = require("react-native");
var _reactNativeMaps = _interopRequireWildcard(require("react-native-maps"));
var _supercluster = _interopRequireDefault(require("supercluster"));
var _ClusteredMarker = _interopRequireDefault(require("./ClusteredMarker"));
var _helpers = require("./helpers");
var _jsxRuntime = require("react/jsx-runtime");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const ClusteredMapView = /*#__PURE__*/(0, _react.forwardRef)(({
  clusteringEnabled = true,
  spiralEnabled = true,
  spiderfyOnMaxZoom = true,
  animationEnabled = true,
  radius = 40,
  maxZoom = 20,
  minZoom = 1,
  minPoints = 2,
  extent = 512,
  nodeSize = 64,
  clusterColor = '#00B386',
  clusterTextColor = '#FFFFFF',
  clusterFontFamily,
  spiderLineColor = '#FF0000',
  edgePadding = {
    top: 50,
    left: 50,
    right: 50,
    bottom: 50
  },
  children,
  onRegionChangeComplete,
  onClusterPress,
  renderCluster,
  tracksViewChanges,
  ...restProps
}, ref) => {
  const [markers, setMarkers] = (0, _react.useState)([]);
  const [spiderMarkers, setSpiderMarkers] = (0, _react.useState)([]);
  const [otherChildren, setOtherChildren] = (0, _react.useState)([]);
  const clustererRef = (0, _react.useRef)(null);
  const mapRef = (0, _react.useRef)(null);
  const {
    width
  } = (0, _reactNative.useWindowDimensions)();
  (0, _react.useImperativeHandle)(ref, () => mapRef.current, []);
  const memoizedChildren = (0, _react.useMemo)(() => _react.default.Children.toArray(children), [children]);
  const handleRegionChange = (0, _react.useCallback)(region => {
    if (clustererRef.current) {
      const bbox = (0, _helpers.calculateBBox)(region);
      const zoom = (0, _helpers.returnMapZoom)(region, width);
      const newMarkers = clustererRef.current.getClusters(bbox, zoom);
      if (animationEnabled && _reactNative.Platform.OS === 'ios') _reactNative.LayoutAnimation.configureNext(_reactNative.LayoutAnimation.Presets.spring);
      setMarkers(newMarkers);
      if (spiralEnabled && spiderfyOnMaxZoom && zoom >= maxZoom) {
        const newSpiderMarkers = newMarkers.flatMap(marker => {
          if ('cluster' in marker.properties) {
            const leaves = clustererRef.current.getLeaves(marker.properties.cluster_id, Infinity);
            return (0, _helpers.generateSpiral)(marker, leaves);
          }
          return [];
        });
        setSpiderMarkers(newSpiderMarkers);
      } else {
        setSpiderMarkers([]);
      }
      onRegionChangeComplete?.(region, {
        isGesture: false
      });
    } else {
      onRegionChangeComplete?.(region, {
        isGesture: false
      });
    }
  }, [animationEnabled, spiralEnabled, spiderfyOnMaxZoom, maxZoom, onRegionChangeComplete, width]);
  (0, _react.useEffect)(() => {
    if (!clusteringEnabled) {
      setMarkers([]);
      setSpiderMarkers([]);
      setOtherChildren(memoizedChildren);
      clustererRef.current = null;
      return;
    }
    const markerData = [];
    const nonMarkerChildren = [];
    memoizedChildren.forEach((child, index) => {
      if ((0, _helpers.isMarker)(child)) {
        markerData.push((0, _helpers.markerToGeoJSONFeature)(child, index));
      } else {
        nonMarkerChildren.push(child);
      }
    });
    clustererRef.current = new _supercluster.default({
      radius,
      maxZoom,
      minZoom,
      minPoints,
      extent,
      nodeSize
    });
    clustererRef.current.load(markerData);
    setOtherChildren(nonMarkerChildren);
    const initialRegion = restProps.region || restProps.initialRegion;
    if (initialRegion) handleRegionChange(initialRegion);
  }, [memoizedChildren, clusteringEnabled, radius, maxZoom, minZoom, minPoints, extent, nodeSize, restProps.region, restProps.initialRegion, handleRegionChange]);
  const handleClusterPress = (0, _react.useCallback)(cluster => {
    if (!clustererRef.current) return;
    const leaves = clustererRef.current.getLeaves(cluster.properties.cluster_id, Infinity);
    onClusterPress?.(cluster, leaves);
    const coordinates = leaves.map(leaf => ({
      latitude: leaf.geometry.coordinates[1],
      longitude: leaf.geometry.coordinates[0]
    }));
    mapRef.current?.fitToCoordinates(coordinates, {
      edgePadding
    });
  }, [onClusterPress, edgePadding]);
  return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_reactNativeMaps.default, {
    ...restProps,
    ref: mapRef,
    onRegionChangeComplete: handleRegionChange,
    children: [markers.map(marker => {
      if ('cluster' in marker.properties) {
        const cluster = marker;
        const onPress = () => handleClusterPress(cluster);
        return renderCluster ? renderCluster(cluster, onPress) : /*#__PURE__*/(0, _jsxRuntime.jsx)(_ClusteredMarker.default, {
          ...cluster,
          onPress: onPress,
          clusterColor: clusterColor,
          clusterTextColor: clusterTextColor,
          clusterFontFamily: clusterFontFamily,
          tracksViewChanges: tracksViewChanges
        }, `cluster-${cluster.id}`);
      }
      const point = marker;
      const originalMarker = memoizedChildren[point.properties.index];
      return spiderMarkers.length > 0 ? null : /*#__PURE__*/_react.default.cloneElement(originalMarker, {
        key: `marker-${point.properties.index}`
      });
    }), otherChildren, spiderMarkers.map(marker => {
      const spiderfiedMarker = memoizedChildren[marker.index];
      return /*#__PURE__*/(0, _jsxRuntime.jsxs)(_react.default.Fragment, {
        children: [/*#__PURE__*/(0, _jsxRuntime.jsx)(_reactNativeMaps.Polyline, {
          coordinates: [marker.centerPoint, {
            latitude: marker.latitude,
            longitude: marker.longitude
          }],
          strokeColor: spiderLineColor,
          strokeWidth: 1
        }), /*#__PURE__*/_react.default.cloneElement(spiderfiedMarker, {
          coordinate: {
            latitude: marker.latitude,
            longitude: marker.longitude
          }
        })]
      }, `spider-${marker.index}`);
    })]
  });
});
var _default = exports.default = /*#__PURE__*/(0, _react.memo)(ClusteredMapView);
//# sourceMappingURL=ClusteredMapView.js.map