"use strict";

import React, { memo, useState, useEffect, useCallback, useRef, forwardRef, useImperativeHandle, useMemo } from 'react';
import { LayoutAnimation, Platform, useWindowDimensions } from 'react-native';
import MapView, { Polyline } from 'react-native-maps';
import SuperCluster from 'supercluster';
import ClusteredMarker from './ClusteredMarker';
import { isMarker, markerToGeoJSONFeature, calculateBBox, returnMapZoom, generateSpiral } from './helpers';
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
const ClusteredMapView = /*#__PURE__*/forwardRef(({
  clusteringEnabled = true,
  spiralEnabled = true,
  spiderfyOnMaxZoom = true,
  animationEnabled = true,
  radius = 40,
  maxZoom = 20,
  minZoom = 1,
  minPoints = 2,
  extent = 512,
  nodeSize = 64,
  clusterColor = '#00B386',
  clusterTextColor = '#FFFFFF',
  clusterFontFamily,
  spiderLineColor = '#FF0000',
  edgePadding = {
    top: 50,
    left: 50,
    right: 50,
    bottom: 50
  },
  children,
  onRegionChangeComplete,
  onClusterPress,
  renderCluster,
  tracksViewChanges,
  ...restProps
}, ref) => {
  const [markers, setMarkers] = useState([]);
  const [spiderMarkers, setSpiderMarkers] = useState([]);
  const [otherChildren, setOtherChildren] = useState([]);
  const clustererRef = useRef(null);
  const mapRef = useRef(null);
  const {
    width
  } = useWindowDimensions();
  useImperativeHandle(ref, () => mapRef.current, []);
  const memoizedChildren = useMemo(() => React.Children.toArray(children), [children]);
  const handleRegionChange = useCallback(region => {
    if (clustererRef.current) {
      const bbox = calculateBBox(region);
      const zoom = returnMapZoom(region, width);
      const newMarkers = clustererRef.current.getClusters(bbox, zoom);
      if (animationEnabled && Platform.OS === 'ios') LayoutAnimation.configureNext(LayoutAnimation.Presets.spring);
      setMarkers(newMarkers);
      if (spiralEnabled && spiderfyOnMaxZoom && zoom >= maxZoom) {
        const newSpiderMarkers = newMarkers.flatMap(marker => {
          if ('cluster' in marker.properties) {
            const leaves = clustererRef.current.getLeaves(marker.properties.cluster_id, Infinity);
            return generateSpiral(marker, leaves);
          }
          return [];
        });
        setSpiderMarkers(newSpiderMarkers);
      } else {
        setSpiderMarkers([]);
      }
      onRegionChangeComplete?.(region, {
        isGesture: false
      });
    } else {
      onRegionChangeComplete?.(region, {
        isGesture: false
      });
    }
  }, [animationEnabled, spiralEnabled, spiderfyOnMaxZoom, maxZoom, onRegionChangeComplete, width]);
  useEffect(() => {
    if (!clusteringEnabled) {
      setMarkers([]);
      setSpiderMarkers([]);
      setOtherChildren(memoizedChildren);
      clustererRef.current = null;
      return;
    }
    const markerData = [];
    const nonMarkerChildren = [];
    memoizedChildren.forEach((child, index) => {
      if (isMarker(child)) {
        markerData.push(markerToGeoJSONFeature(child, index));
      } else {
        nonMarkerChildren.push(child);
      }
    });
    clustererRef.current = new SuperCluster({
      radius,
      maxZoom,
      minZoom,
      minPoints,
      extent,
      nodeSize
    });
    clustererRef.current.load(markerData);
    setOtherChildren(nonMarkerChildren);
    const initialRegion = restProps.region || restProps.initialRegion;
    if (initialRegion) handleRegionChange(initialRegion);
  }, [memoizedChildren, clusteringEnabled, radius, maxZoom, minZoom, minPoints, extent, nodeSize, restProps.region, restProps.initialRegion, handleRegionChange]);
  const handleClusterPress = useCallback(cluster => {
    if (!clustererRef.current) return;
    const leaves = clustererRef.current.getLeaves(cluster.properties.cluster_id, Infinity);
    onClusterPress?.(cluster, leaves);
    const coordinates = leaves.map(leaf => ({
      latitude: leaf.geometry.coordinates[1],
      longitude: leaf.geometry.coordinates[0]
    }));
    mapRef.current?.fitToCoordinates(coordinates, {
      edgePadding
    });
  }, [onClusterPress, edgePadding]);
  return /*#__PURE__*/_jsxs(MapView, {
    ...restProps,
    ref: mapRef,
    onRegionChangeComplete: handleRegionChange,
    children: [markers.map(marker => {
      if ('cluster' in marker.properties) {
        const cluster = marker;
        const onPress = () => handleClusterPress(cluster);
        return renderCluster ? renderCluster(cluster, onPress) : /*#__PURE__*/_jsx(ClusteredMarker, {
          ...cluster,
          onPress: onPress,
          clusterColor: clusterColor,
          clusterTextColor: clusterTextColor,
          clusterFontFamily: clusterFontFamily,
          tracksViewChanges: tracksViewChanges
        }, `cluster-${cluster.id}`);
      }
      const point = marker;
      const originalMarker = memoizedChildren[point.properties.index];
      return spiderMarkers.length > 0 ? null : /*#__PURE__*/React.cloneElement(originalMarker, {
        key: `marker-${point.properties.index}`
      });
    }), otherChildren, spiderMarkers.map(marker => {
      const spiderfiedMarker = memoizedChildren[marker.index];
      return /*#__PURE__*/_jsxs(React.Fragment, {
        children: [/*#__PURE__*/_jsx(Polyline, {
          coordinates: [marker.centerPoint, {
            latitude: marker.latitude,
            longitude: marker.longitude
          }],
          strokeColor: spiderLineColor,
          strokeWidth: 1
        }), /*#__PURE__*/React.cloneElement(spiderfiedMarker, {
          coordinate: {
            latitude: marker.latitude,
            longitude: marker.longitude
          }
        })]
      }, `spider-${marker.index}`);
    })]
  });
});
export default /*#__PURE__*/memo(ClusteredMapView);
//# sourceMappingURL=ClusteredMapView.js.map